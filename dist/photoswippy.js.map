{"version":3,"file":"photoswippy.js","sources":["../src/index.js","../src/helpers.js"],"sourcesContent":["import {\n  slice,\n  closest,\n  assign,\n  getElementIndex,\n  selectorMatches,\n  getURLHash,\n  preloadImage\n} from './helpers.js'\n\nlet PhotoSwipe\nlet PhotoSwipeUI\nlet PhotoSwipeGlobalOptions\nlet PhotoswipeTemplate\nlet galleryCount = 0\nlet galleryList = {}\n\nconst defaultPhotoswippyOptions = {\n  indexSelector: null,\n  itemSelector: 'a',\n  captionSelector: 'figcaption',\n  hoverPreload: false,\n  useMsrc: true,\n  eventListener: []\n}\n\nconst openPhotoSwipe = (gallery, curIndex, openTriggerEl) => {\n  openTriggerEl = openTriggerEl ||\n    gallery.items[curIndex].el.querySelector('img') || {\n    offsetWidth: 0,\n    offsetHeight: 0\n  }\n\n  const options = assign({}, gallery.options, {\n    index: curIndex,\n    getThumbBoundsFn (index) {\n      /**\n       * The default trigger element is the gallery item at `index`.\n       * If the gallery item isn't visible (offsetParent will be null),\n       * use the element which triggered the gallery\n       */\n      const actionTriggerEl = gallery.items[index].el.offsetParent\n        ? gallery.items[index].el\n        : openTriggerEl\n\n      /** If the trigger element is visible, calculate and return it's frame */\n      if (actionTriggerEl.offsetParent) {\n        const pageYScroll =\n          window.pageYOffset || document.documentElement.scrollTop\n        const triggerElFrame = actionTriggerEl.getBoundingClientRect()\n\n        return {\n          x: triggerElFrame.left,\n          y: triggerElFrame.top + pageYScroll,\n          w: triggerElFrame.width\n        }\n      }\n    }\n  })\n\n  const pswpGallery = new PhotoSwipe(\n    PhotoswipeTemplate,\n    PhotoSwipeUI,\n    gallery.items,\n    options\n  )\n\n  // Set width and height if not previously defined\n  pswpGallery.listen('gettingData', (index, item) => {\n    if (!item.w || !item.h) {\n      item.w = openTriggerEl.offsetWidth\n      item.h = openTriggerEl.offsetHeight\n\n      if (!options.hoverPreload || !item.preloadState) {\n        preloadImage(item.src, img => {\n          item.w = img.width\n          item.h = img.height\n          pswpGallery.updateSize(true)\n        })\n      }\n    }\n  })\n\n  /**\n   * We add an array with listeners to the options,\n   * so we can supply external functionality to the photoswipe object at init.\n   * It is added like that:\n   * const options = {\n      eventListener: [\n        {\n          name: 'initialZoomIn',\n          callback: function() {\n            console.log('initialZoomIn');\n          }\n        },\n        {\n          name: 'destroy',\n          callback: function() {\n            console.log('destroy');\n          }\n        }\n      ]\n    };\n    photoswippy.init(PhotoSwipe, PhotoSwipeUI_Default, options);\n   */\n  pswpGallery.options.eventListener.forEach( listener => {\n    pswpGallery.listen(listener.name, listener.callback);\n  })\n\n  pswpGallery.init()\n}\n\nconst handleGalleryClick = gallery => e => {\n  e.preventDefault()\n\n  /*\n* Go up the DOM tree until it finds\n* the clicked item (matches the itemSelector)\n*/\n  const currentItem = closest(\n    e.target,\n    el => el.nodeType === 1 && selectorMatches(el, gallery.options.itemSelector)\n  )\n\n  // If the click didn't hit a gallery item, do nothing\n  if (!currentItem) return\n\n  /*\n* Let's get the clicked item index.\n* If indexSelector is null, let's assume the gallery element direct child.\n* If not null, let's search for a selector match and find it index.\n*/\n  const indexItemEl = closest(\n    currentItem,\n    typeof gallery.options.indexSelector === 'string'\n      ? el => selectorMatches(el, gallery.options.indexSelector)\n      : el => el.parentNode === gallery.el\n  )\n  const actualIndex = getElementIndex(indexItemEl)\n  openPhotoSwipe(gallery, actualIndex, currentItem)\n}\n\nconst buildGallery = (galleryEl, galleryOptions = {}) => {\n  /** Reads the data-pswp-options */\n  if (galleryEl.dataset.pswpOptions) {\n    galleryOptions = JSON.parse(galleryEl.dataset.pswpOptions)\n  } else {\n    /** Or the data-pswp-{kebabed-property}=\"value\" */\n    const relevantKeys = Object.keys(galleryEl.dataset).filter(\n      k => k.indexOf('pswp') === 0 && k !== 'pswp'\n    )\n    if (relevantKeys.length > 0) {\n      relevantKeys.forEach(datasetKey => {\n        const realKey = datasetKey[4].toLowerCase() + datasetKey.substring(5)\n        /** Set to the passed value or as true if we only found the attribute key */\n        galleryOptions[realKey] = galleryEl.dataset[datasetKey] || true\n      })\n    }\n  }\n\n  const options = assign(\n    // Default gallery ID\n    {\n      galleryUID:\n        galleryEl.dataset.pswpId ||\n        galleryEl.dataset.pswp ||\n        `gallery-${galleryCount}`\n    },\n    // Default options\n    PhotoSwipeGlobalOptions,\n    // Assign the options object if available. Otherwise, try to parse data-pswp\n    galleryOptions\n  )\n\n  /* Update the element data-pswp attribute\n* with the actual ID (useful for generated ones)\n*/\n  galleryEl.dataset.pswp = options.galleryUID\n\n  const items = slice(galleryEl.querySelectorAll(options.itemSelector)).map(\n    itemEl => {\n      const captionEl = itemEl.querySelector(options.captionSelector) || {}\n\n      const [width, height] = (itemEl.dataset.pswpSize || '')\n        .toLowerCase()\n        .split('x')\n        .map(parseInt)\n\n      const w = width || itemEl.dataset.pswpWidth || 0\n      const h = height || itemEl.dataset.pswpHeight || 0\n      const title = itemEl.dataset.pswpCaption || captionEl.innerHTML || ''\n      const src = itemEl.dataset.pswpSrc || itemEl.href\n      const galleryItem = { el: itemEl, src, w, h, title }\n\n      if (options.useMsrc) {\n        /** If options.useMsrc is true, look for the 'src' attribute of the gallery item thumbnail <img/> element. */\n        const imageEl = itemEl.querySelector('img')\n        if (imageEl) {\n          galleryItem.msrc = imageEl.src\n        }\n      }\n\n      if (options.hoverPreload) {\n        itemEl.addEventListener('mouseover', function itemHover (e) {\n          if (!galleryItem.preloadState) {\n            galleryItem.preloadState = 1\n            preloadImage(\n              src,\n              img => {\n                galleryItem.preloadState = 2\n                galleryItem.w = img.width\n                galleryItem.h = img.height\n                itemEl.removeEventListener('mouseover', itemHover)\n              },\n              () => {\n                /** Reset the preload state in case of error and remove the listener */\n                galleryItem.preloadState = 0\n                itemEl.removeEventListener('mouseover', itemHover)\n              }\n            )\n          }\n        })\n      }\n\n      return galleryItem\n    }\n  )\n\n  const gallery = { el: galleryEl, options, items }\n  galleryEl.addEventListener('click', handleGalleryClick(gallery))\n\n  return gallery\n}\n\nconst build = (elOrSelector, options) => {\n  if (!PhotoSwipe || !PhotoSwipeUI) {\n    console.error(\n      '[PhotoSwippy] PhotoSwipe and PhotoSwipeUI libraries were not found. Was \"PhotoSwippy.init()\" called?'\n    )\n  }\n\n  if (!elOrSelector) return\n\n  const galleryEls =\n    typeof elOrSelector === 'string'\n      ? slice(document.querySelectorAll(elOrSelector))\n      : [elOrSelector]\n\n  galleryEls.forEach(galleryEl => {\n    if (!galleryEl.photoswippy) {\n      galleryCount++\n      const gallery = buildGallery(galleryEl, options)\n      galleryEl.photoswippy = true\n      galleryList[gallery.options.galleryUID] = gallery\n    }\n  })\n\n  /** If url's hash has a 'pid' and a 'gid', let's open that gallery */\n  const urlHash = getURLHash()\n  if (urlHash.pid && urlHash.gid && galleryList[urlHash.gid]) {\n    openPhotoSwipe(galleryList[urlHash.gid], urlHash.pid - 1, null)\n  }\n  refreshTriggers()\n}\n\n/*\n* Search for `data-pswp-trigger=\"gallery-id\"` elements to be used\n* as triggers to open a specific gallery.\n*/\nconst refreshTriggers = () => {\n  const triggers = slice(document.querySelectorAll('[data-pswp-trigger]'))\n  triggers.forEach(trigger => {\n    if (!trigger.photoswippy) {\n      trigger.photoswippy = true\n      trigger.addEventListener('click', function () {\n        const [galleryID, index = 0] = this.dataset.pswpTrigger.split('@')\n        const gallery = galleryList[galleryID]\n        if (!gallery) {\n          console.error(\n            `[PhotoSwippy] Gallery with id '${galleryID}' not found.`\n          )\n        } else {\n          /** Open gallery passing the trigger element and the initial item (always the first gallery entry) */\n          openPhotoSwipe(gallery, parseInt(index), this)\n        }\n      })\n    }\n  })\n}\n\nconst init = (\n  pswpLib = window.PhotoSwipe,\n  pswpUILib = window.PhotoSwipeUI_Default,\n  options\n) => {\n  PhotoSwipe = pswpLib\n  PhotoSwipeUI = pswpUILib\n  PhotoSwipeGlobalOptions = assign(defaultPhotoswippyOptions, options)\n  PhotoswipeTemplate = document.querySelector('.pswp')\n\n  if (!PhotoswipeTemplate) {\n    console.error(\n      '[PhotoSwippy] Photoswipe template (Element with .pswp class) not found.'\n    )\n  }\n\n  // Initialize all available galleries (data-pswp)\n  build('[data-pswp]')\n}\n\nexport default {\n  init,\n  build\n}\n","/** Clones an array-like */\nexport const slice = arrayLike => Array.prototype.slice.call(arrayLike)\n\n/** Finds the closest hierarchical parent that matches a certain condition */\nexport const closest = (el, fn) =>\n  el && (fn(el) ? el : closest(el.parentNode, fn))\n\n/** Preloads an image and executes a callback */\nexport const preloadImage = (url, onLoad, onError) => {\n  const tmpImg = new Image()\n  tmpImg.onload = () => onLoad(tmpImg)\n  if (onError) {\n    tmpImg.onerror = () => onError(tmpImg)\n  }\n  tmpImg.src = url\n}\n/** Gets an element index relative to its siblings */\nexport const getElementIndex = node => {\n  let index = 0\n  while ((node = node.previousElementSibling)) {\n    ++index\n  }\n  return index\n}\n\n/** Cross-browser Element.matches */\nexport const selectorMatches = (el, selector) => {\n  const fn =\n    Element.prototype.matches ||\n    Element.prototype.webkitMatchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector\n  return fn.call(el, selector)\n}\n\n/** Transform the url hash into an object */\nexport const getURLHash = () => {\n  const hashData = window.location.hash\n    .substring(1)\n    .split('&')\n    .reduce((acc, cur) => {\n      if (cur.length) {\n        const [id, index] = cur.split('=')\n        acc[id] = index\n      }\n      return acc\n    }, {})\n\n  return hashData\n}\n\n/** Object.assign ponyfill */\nexport const assign =\n  Object.assign ||\n  function (target /* sources */) {\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object')\n    }\n    const output = Object(target)\n\n    for (let index = 1; index < arguments.length; index++) {\n      const source = arguments[index]\n      if (source != null) {\n        for (const nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey]\n          }\n        }\n      }\n    }\n    return output\n  }\n"],"names":["PhotoSwipe","PhotoSwipeUI","PhotoSwipeGlobalOptions","PhotoswipeTemplate","slice","arrayLike","Array","prototype","call","closest","el","fn","parentNode","preloadImage","url","onLoad","onError","tmpImg","Image","onload","onerror","src","selectorMatches","selector","Element","matches","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","assign","Object","target","TypeError","output","index","arguments","length","source","nextKey","hasOwnProperty","galleryCount","galleryList","defaultPhotoswippyOptions","indexSelector","itemSelector","captionSelector","hoverPreload","useMsrc","eventListener","openPhotoSwipe","gallery","curIndex","openTriggerEl","items","querySelector","offsetWidth","offsetHeight","options","getThumbBoundsFn","actionTriggerEl","offsetParent","pageYScroll","window","pageYOffset","document","documentElement","scrollTop","triggerElFrame","getBoundingClientRect","x","left","y","top","w","width","pswpGallery","listen","item","h","preloadState","img","height","updateSize","forEach","listener","name","callback","init","build","elOrSelector","console","error","querySelectorAll","galleryEl","photoswippy","galleryOptions","dataset","pswpOptions","JSON","parse","relevantKeys","keys","filter","k","indexOf","datasetKey","realKey","toLowerCase","substring","galleryUID","pswpId","pswp","map","itemEl","captionEl","pswpSize","split","parseInt","pswpSrc","href","galleryItem","pswpWidth","pswpHeight","title","pswpCaption","innerHTML","imageEl","msrc","addEventListener","itemHover","e","removeEventListener","preventDefault","currentItem","nodeType","actualIndex","node","previousElementSibling","getElementIndex","handleGalleryClick","buildGallery","urlHash","location","hash","reduce","acc","cur","pid","gid","refreshTriggers","trigger","this","pswpTrigger","galleryID","pswpLib","pswpUILib","PhotoSwipeUI_Default"],"mappings":"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"}