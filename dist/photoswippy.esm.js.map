{"version":3,"file":"photoswippy.esm.js","sources":["../src/helpers.js","../src/index.js"],"sourcesContent":["/** Clones an array-like */\nexport const slice = arrayLike => Array.prototype.slice.call(arrayLike)\n\n/** Finds the closest hierarchical parent that matches a certain condition */\nexport const closest = (el, fn) =>\n  el && (fn(el) ? el : closest(el.parentNode, fn))\n\n/** Preloads an image and executes a callback */\nexport const preloadImage = (url, onLoad, onError) => {\n  const tmpImg = new Image()\n  tmpImg.onload = () => onLoad(tmpImg)\n  if (onError) {\n    tmpImg.onerror = () => onError(tmpImg)\n  }\n  tmpImg.src = url\n}\n/** Gets an element index relative to its siblings */\nexport const getElementIndex = node => {\n  let index = 0\n  while ((node = node.previousElementSibling)) {\n    ++index\n  }\n  return index\n}\n\n/** Cross-browser Element.matches */\nexport const selectorMatches = (el, selector) => {\n  const fn =\n    Element.prototype.matches ||\n    Element.prototype.webkitMatchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector\n  return fn.call(el, selector)\n}\n\n/** Transform the url hash into an object */\nexport const getURLHash = () => {\n  const hashData = window.location.hash\n    .substring(1)\n    .split('&')\n    .reduce((acc, cur) => {\n      if (cur.length) {\n        const [id, index] = cur.split('=')\n        acc[id] = index\n      }\n      return acc\n    }, {})\n\n  return hashData\n}\n\n/** Object.assign ponyfill */\nexport const assign =\n  Object.assign ||\n  function (target /* sources */) {\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object')\n    }\n    const output = Object(target)\n\n    for (let index = 1; index < arguments.length; index++) {\n      const source = arguments[index]\n      if (source != null) {\n        for (const nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey]\n          }\n        }\n      }\n    }\n    return output\n  }\n","import {\n  slice,\n  closest,\n  assign,\n  getElementIndex,\n  selectorMatches,\n  getURLHash,\n  preloadImage\n} from './helpers.js'\n\nlet PhotoSwipe\nlet PhotoSwipeUI\nlet PhotoSwipeGlobalOptions\nlet PhotoswipeTemplate\nlet galleryCount = 0\nlet galleryList = {}\n\nconst defaultPhotoswippyOptions = {\n  indexSelector: null,\n  itemSelector: 'a',\n  captionSelector: 'figcaption',\n  hoverPreload: false,\n  useMsrc: true,\n  eventListener: []\n}\n\nconst openPhotoSwipe = (gallery, curIndex, openTriggerEl) => {\n  openTriggerEl = openTriggerEl ||\n    gallery.items[curIndex].el.querySelector('img') || {\n    offsetWidth: 0,\n    offsetHeight: 0\n  }\n\n  const options = assign({}, gallery.options, {\n    index: curIndex,\n    getThumbBoundsFn (index) {\n      /**\n       * The default trigger element is the gallery item at `index`.\n       * If the gallery item isn't visible (offsetParent will be null),\n       * use the element which triggered the gallery\n       */\n      const actionTriggerEl = gallery.items[index].el.offsetParent\n        ? gallery.items[index].el\n        : openTriggerEl\n\n      /** If the trigger element is visible, calculate and return it's frame */\n      if (actionTriggerEl.offsetParent) {\n        const pageYScroll =\n          window.pageYOffset || document.documentElement.scrollTop\n        const triggerElFrame = actionTriggerEl.getBoundingClientRect()\n\n        return {\n          x: triggerElFrame.left,\n          y: triggerElFrame.top + pageYScroll,\n          w: triggerElFrame.width\n        }\n      }\n    }\n  })\n\n  const pswpGallery = new PhotoSwipe(\n    PhotoswipeTemplate,\n    PhotoSwipeUI,\n    gallery.items,\n    options\n  )\n\n  // Set width and height if not previously defined\n  pswpGallery.listen('gettingData', (index, item) => {\n    if (!item.w || !item.h) {\n      item.w = openTriggerEl.offsetWidth\n      item.h = openTriggerEl.offsetHeight\n\n      if (!options.hoverPreload || !item.preloadState) {\n        preloadImage(item.src, img => {\n          item.w = img.width\n          item.h = img.height\n          pswpGallery.updateSize(true)\n        })\n      }\n    }\n  }),\n\n  /**\n   * We add an array with listeners to the options,\n   * so we can supply external functionality to the photoswipe object at init.\n   * It is added like that:\n   * const options = {\n      eventListener: [\n        {\n          name: 'initialZoomIn',\n          callback: function() {\n            console.log('initialZoomIn');\n          }\n        },\n        {\n          name: 'destroy',\n          callback: function() {\n            console.log('destroy');\n          }\n        }\n      ]\n    };\n    photoswippy.init(PhotoSwipe, PhotoSwipeUI_Default, options);\n   */\n  pswpGallery.options.eventListener.forEach( listener => {\n    pswpGallery.listen(listener.name, listener.callback());\n  }),\n\n  pswpGallery.init()\n}\n\nconst handleGalleryClick = gallery => e => {\n  e.preventDefault()\n\n  /*\n* Go up the DOM tree until it finds\n* the clicked item (matches the itemSelector)\n*/\n  const currentItem = closest(\n    e.target,\n    el => el.nodeType === 1 && selectorMatches(el, gallery.options.itemSelector)\n  )\n\n  // If the click didn't hit a gallery item, do nothing\n  if (!currentItem) return\n\n  /*\n* Let's get the clicked item index.\n* If indexSelector is null, let's assume the gallery element direct child.\n* If not null, let's search for a selector match and find it index.\n*/\n  const indexItemEl = closest(\n    currentItem,\n    typeof gallery.options.indexSelector === 'string'\n      ? el => selectorMatches(el, gallery.options.indexSelector)\n      : el => el.parentNode === gallery.el\n  )\n  const actualIndex = getElementIndex(indexItemEl)\n  openPhotoSwipe(gallery, actualIndex, currentItem)\n}\n\nconst buildGallery = (galleryEl, galleryOptions = {}) => {\n  /** Reads the data-pswp-options */\n  if (galleryEl.dataset.pswpOptions) {\n    galleryOptions = JSON.parse(galleryEl.dataset.pswpOptions)\n  } else {\n    /** Or the data-pswp-{kebabed-property}=\"value\" */\n    const relevantKeys = Object.keys(galleryEl.dataset).filter(\n      k => k.indexOf('pswp') === 0 && k !== 'pswp'\n    )\n    if (relevantKeys.length > 0) {\n      relevantKeys.forEach(datasetKey => {\n        const realKey = datasetKey[4].toLowerCase() + datasetKey.substring(5)\n        /** Set to the passed value or as true if we only found the attribute key */\n        galleryOptions[realKey] = galleryEl.dataset[datasetKey] || true\n      })\n    }\n  }\n\n  const options = assign(\n    // Default gallery ID\n    {\n      galleryUID:\n        galleryEl.dataset.pswpId ||\n        galleryEl.dataset.pswp ||\n        `gallery-${galleryCount}`\n    },\n    // Default options\n    PhotoSwipeGlobalOptions,\n    // Assign the options object if available. Otherwise, try to parse data-pswp\n    galleryOptions\n  )\n\n  /* Update the element data-pswp attribute\n* with the actual ID (useful for generated ones)\n*/\n  galleryEl.dataset.pswp = options.galleryUID\n\n  const items = slice(galleryEl.querySelectorAll(options.itemSelector)).map(\n    itemEl => {\n      const captionEl = itemEl.querySelector(options.captionSelector) || {}\n\n      const [width, height] = (itemEl.dataset.pswpSize || '')\n        .toLowerCase()\n        .split('x')\n        .map(parseInt)\n\n      const w = width || itemEl.dataset.pswpWidth || 0\n      const h = height || itemEl.dataset.pswpHeight || 0\n      const title = itemEl.dataset.pswpCaption || captionEl.innerHTML || ''\n      const src = itemEl.dataset.pswpSrc || itemEl.href\n      const galleryItem = { el: itemEl, src, w, h, title }\n\n      if (options.useMsrc) {\n        /** If options.useMsrc is true, look for the 'src' attribute of the gallery item thumbnail <img/> element. */\n        const imageEl = itemEl.querySelector('img')\n        if (imageEl) {\n          galleryItem.msrc = imageEl.src\n        }\n      }\n\n      if (options.hoverPreload) {\n        itemEl.addEventListener('mouseover', function itemHover (e) {\n          if (!galleryItem.preloadState) {\n            galleryItem.preloadState = 1\n            preloadImage(\n              src,\n              img => {\n                galleryItem.preloadState = 2\n                galleryItem.w = img.width\n                galleryItem.h = img.height\n                itemEl.removeEventListener('mouseover', itemHover)\n              },\n              () => {\n                /** Reset the preload state in case of error and remove the listener */\n                galleryItem.preloadState = 0\n                itemEl.removeEventListener('mouseover', itemHover)\n              }\n            )\n          }\n        })\n      }\n\n      return galleryItem\n    }\n  )\n\n  const gallery = { el: galleryEl, options, items }\n  galleryEl.addEventListener('click', handleGalleryClick(gallery))\n\n  return gallery\n}\n\nconst build = (elOrSelector, options) => {\n  if (!PhotoSwipe || !PhotoSwipeUI) {\n    console.error(\n      '[PhotoSwippy] PhotoSwipe and PhotoSwipeUI libraries were not found. Was \"PhotoSwippy.init()\" called?'\n    )\n  }\n\n  if (!elOrSelector) return\n\n  const galleryEls =\n    typeof elOrSelector === 'string'\n      ? slice(document.querySelectorAll(elOrSelector))\n      : [elOrSelector]\n\n  galleryEls.forEach(galleryEl => {\n    if (!galleryEl.photoswippy) {\n      galleryCount++\n      const gallery = buildGallery(galleryEl, options)\n      galleryEl.photoswippy = true\n      galleryList[gallery.options.galleryUID] = gallery\n    }\n  })\n\n  /** If url's hash has a 'pid' and a 'gid', let's open that gallery */\n  const urlHash = getURLHash()\n  if (urlHash.pid && urlHash.gid && galleryList[urlHash.gid]) {\n    openPhotoSwipe(galleryList[urlHash.gid], urlHash.pid - 1, null)\n  }\n  refreshTriggers()\n}\n\n/*\n* Search for `data-pswp-trigger=\"gallery-id\"` elements to be used\n* as triggers to open a specific gallery.\n*/\nconst refreshTriggers = () => {\n  const triggers = slice(document.querySelectorAll('[data-pswp-trigger]'))\n  triggers.forEach(trigger => {\n    if (!trigger.photoswippy) {\n      trigger.photoswippy = true\n      trigger.addEventListener('click', function () {\n        const [galleryID, index = 0] = this.dataset.pswpTrigger.split('@')\n        const gallery = galleryList[galleryID]\n        if (!gallery) {\n          console.error(\n            `[PhotoSwippy] Gallery with id '${galleryID}' not found.`\n          )\n        } else {\n          /** Open gallery passing the trigger element and the initial item (always the first gallery entry) */\n          openPhotoSwipe(gallery, parseInt(index), this)\n        }\n      })\n    }\n  })\n}\n\nconst init = (\n  pswpLib = window.PhotoSwipe,\n  pswpUILib = window.PhotoSwipeUI_Default,\n  options\n) => {\n  PhotoSwipe = pswpLib\n  PhotoSwipeUI = pswpUILib\n  PhotoSwipeGlobalOptions = assign(defaultPhotoswippyOptions, options)\n  PhotoswipeTemplate = document.querySelector('.pswp')\n\n  if (!PhotoswipeTemplate) {\n    console.error(\n      '[PhotoSwippy] Photoswipe template (Element with .pswp class) not found.'\n    )\n  }\n\n  // Initialize all available galleries (data-pswp)\n  build('[data-pswp]')\n}\n\nexport default {\n  init,\n  build\n}\n"],"names":["const","PhotoSwipe","PhotoSwipeUI","PhotoSwipeGlobalOptions","PhotoswipeTemplate","slice","arrayLike","Array","prototype","call","closest","el","fn","parentNode","preloadImage","url","onLoad","onError","tmpImg","Image","onload","onerror","src","selectorMatches","selector","Element","matches","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","assign","Object","target","TypeError","output","index","arguments","length","source","nextKey","hasOwnProperty","galleryCount","galleryList","defaultPhotoswippyOptions","indexSelector","itemSelector","captionSelector","hoverPreload","useMsrc","eventListener","openPhotoSwipe","gallery","curIndex","openTriggerEl","items","querySelector","offsetWidth","offsetHeight","options","getThumbBoundsFn","actionTriggerEl","offsetParent","pageYScroll","window","pageYOffset","document","documentElement","scrollTop","triggerElFrame","getBoundingClientRect","x","left","y","top","w","width","pswpGallery","listen","item","h","preloadState","img","height","updateSize","forEach","listener","name","callback","init","buildGallery","galleryEl","galleryOptions","dataset","pswpOptions","JSON","parse","relevantKeys","keys","filter","k","indexOf","datasetKey","realKey","toLowerCase","substring","galleryUID","pswpId","pswp","querySelectorAll","map","itemEl","captionEl","pswpSize","split","parseInt","pswpSrc","href","galleryItem","pswpWidth","pswpHeight","pswpCaption","innerHTML","imageEl","msrc","addEventListener","itemHover","e","removeEventListener","preventDefault","currentItem","nodeType","actualIndex","node","let","previousElementSibling","getElementIndex","handleGalleryClick","build","elOrSelector","console","error","photoswippy","urlHash","location","hash","reduce","acc","cur","pid","gid","refreshTriggers","trigger","this","pswpTrigger","galleryID","pswpLib","pswpUILib","PhotoSwipeUI_Default"],"mappings":"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"}