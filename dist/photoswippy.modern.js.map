{"version":3,"file":"photoswippy.modern.js","sources":["../src/helpers.js","../src/index.js"],"sourcesContent":["/** Clones an array-like */\nexport const slice = arrayLike => Array.prototype.slice.call(arrayLike)\n\n/** Finds the closest hierarchical parent that matches a certain condition */\nexport const closest = (el, fn) =>\n  el && (fn(el) ? el : closest(el.parentNode, fn))\n\n/** Preloads an image and executes a callback */\nexport const preloadImage = (url, onLoad, onError) => {\n  const tmpImg = new Image()\n  tmpImg.onload = () => onLoad(tmpImg)\n  if (onError) {\n    tmpImg.onerror = () => onError(tmpImg)\n  }\n  tmpImg.src = url\n}\n/** Gets an element index relative to its siblings */\nexport const getElementIndex = node => {\n  let index = 0\n  while ((node = node.previousElementSibling)) {\n    ++index\n  }\n  return index\n}\n\n/** Cross-browser Element.matches */\nexport const selectorMatches = (el, selector) => {\n  const fn =\n    Element.prototype.matches ||\n    Element.prototype.webkitMatchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector\n  return fn.call(el, selector)\n}\n\n/** Transform the url hash into an object */\nexport const getURLHash = () => {\n  const hashData = window.location.hash\n    .substring(1)\n    .split('&')\n    .reduce((acc, cur) => {\n      if (cur.length) {\n        const [id, index] = cur.split('=')\n        acc[id] = index\n      }\n      return acc\n    }, {})\n\n  return hashData\n}\n\n/** Object.assign ponyfill */\nexport const assign =\n  Object.assign ||\n  function (target /* sources */) {\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object')\n    }\n    const output = Object(target)\n\n    for (let index = 1; index < arguments.length; index++) {\n      const source = arguments[index]\n      if (source != null) {\n        for (const nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey]\n          }\n        }\n      }\n    }\n    return output\n  }\n","import {\n  slice,\n  closest,\n  assign,\n  getElementIndex,\n  selectorMatches,\n  getURLHash,\n  preloadImage\n} from './helpers.js'\n\nlet PhotoSwipe\nlet PhotoSwipeUI\nlet PhotoSwipeGlobalOptions\nlet PhotoswipeTemplate\nlet galleryCount = 0\nlet galleryList = {}\n\nconst defaultPhotoswippyOptions = {\n  indexSelector: null,\n  itemSelector: 'a',\n  captionSelector: 'figcaption',\n  hoverPreload: false,\n  useMsrc: true,\n  eventListener: []\n}\n\nconst openPhotoSwipe = (gallery, curIndex, openTriggerEl) => {\n  openTriggerEl = openTriggerEl ||\n    gallery.items[curIndex].el.querySelector('img') || {\n    offsetWidth: 0,\n    offsetHeight: 0\n  }\n\n  const options = assign({}, gallery.options, {\n    index: curIndex,\n    getThumbBoundsFn (index) {\n      /**\n       * The default trigger element is the gallery item at `index`.\n       * If the gallery item isn't visible (offsetParent will be null),\n       * use the element which triggered the gallery\n       */\n      const actionTriggerEl = gallery.items[index].el.offsetParent\n        ? gallery.items[index].el\n        : openTriggerEl\n\n      /** If the trigger element is visible, calculate and return it's frame */\n      if (actionTriggerEl.offsetParent) {\n        const pageYScroll =\n          window.pageYOffset || document.documentElement.scrollTop\n        const triggerElFrame = actionTriggerEl.getBoundingClientRect()\n\n        return {\n          x: triggerElFrame.left,\n          y: triggerElFrame.top + pageYScroll,\n          w: triggerElFrame.width\n        }\n      }\n    }\n  })\n\n  const pswpGallery = new PhotoSwipe(\n    PhotoswipeTemplate,\n    PhotoSwipeUI,\n    gallery.items,\n    options\n  )\n\n  // Set width and height if not previously defined\n  pswpGallery.listen('gettingData', (index, item) => {\n    if (!item.w || !item.h) {\n      item.w = openTriggerEl.offsetWidth\n      item.h = openTriggerEl.offsetHeight\n\n      if (!options.hoverPreload || !item.preloadState) {\n        preloadImage(item.src, img => {\n          item.w = img.width\n          item.h = img.height\n          pswpGallery.updateSize(true)\n        })\n      }\n    }\n  }),\n\n  /**\n   * We add an array with listeners to the options,\n   * so we can supply external functionality to the photoswipe object at init.\n   * It is added like that:\n   * const options = {\n      eventListener: [\n        {\n          name: 'initialZoomIn',\n          callback: function() {\n            console.log('initialZoomIn');\n          }\n        },\n        {\n          name: 'destroy',\n          callback: function() {\n            console.log('destroy');\n          }\n        }\n      ]\n    };\n    photoswippy.init(PhotoSwipe, PhotoSwipeUI_Default, options);\n   */\n  pswpGallery.options.eventListener.forEach( listener => {\n    pswpGallery.listen(listener.name, listener.callback());\n  }),\n\n  pswpGallery.init()\n}\n\nconst handleGalleryClick = gallery => e => {\n  e.preventDefault()\n\n  /*\n* Go up the DOM tree until it finds\n* the clicked item (matches the itemSelector)\n*/\n  const currentItem = closest(\n    e.target,\n    el => el.nodeType === 1 && selectorMatches(el, gallery.options.itemSelector)\n  )\n\n  // If the click didn't hit a gallery item, do nothing\n  if (!currentItem) return\n\n  /*\n* Let's get the clicked item index.\n* If indexSelector is null, let's assume the gallery element direct child.\n* If not null, let's search for a selector match and find it index.\n*/\n  const indexItemEl = closest(\n    currentItem,\n    typeof gallery.options.indexSelector === 'string'\n      ? el => selectorMatches(el, gallery.options.indexSelector)\n      : el => el.parentNode === gallery.el\n  )\n  const actualIndex = getElementIndex(indexItemEl)\n  openPhotoSwipe(gallery, actualIndex, currentItem)\n}\n\nconst buildGallery = (galleryEl, galleryOptions = {}) => {\n  /** Reads the data-pswp-options */\n  if (galleryEl.dataset.pswpOptions) {\n    galleryOptions = JSON.parse(galleryEl.dataset.pswpOptions)\n  } else {\n    /** Or the data-pswp-{kebabed-property}=\"value\" */\n    const relevantKeys = Object.keys(galleryEl.dataset).filter(\n      k => k.indexOf('pswp') === 0 && k !== 'pswp'\n    )\n    if (relevantKeys.length > 0) {\n      relevantKeys.forEach(datasetKey => {\n        const realKey = datasetKey[4].toLowerCase() + datasetKey.substring(5)\n        /** Set to the passed value or as true if we only found the attribute key */\n        galleryOptions[realKey] = galleryEl.dataset[datasetKey] || true\n      })\n    }\n  }\n\n  const options = assign(\n    // Default gallery ID\n    {\n      galleryUID:\n        galleryEl.dataset.pswpId ||\n        galleryEl.dataset.pswp ||\n        `gallery-${galleryCount}`\n    },\n    // Default options\n    PhotoSwipeGlobalOptions,\n    // Assign the options object if available. Otherwise, try to parse data-pswp\n    galleryOptions\n  )\n\n  /* Update the element data-pswp attribute\n* with the actual ID (useful for generated ones)\n*/\n  galleryEl.dataset.pswp = options.galleryUID\n\n  const items = slice(galleryEl.querySelectorAll(options.itemSelector)).map(\n    itemEl => {\n      const captionEl = itemEl.querySelector(options.captionSelector) || {}\n\n      const [width, height] = (itemEl.dataset.pswpSize || '')\n        .toLowerCase()\n        .split('x')\n        .map(parseInt)\n\n      const w = width || itemEl.dataset.pswpWidth || 0\n      const h = height || itemEl.dataset.pswpHeight || 0\n      const title = itemEl.dataset.pswpCaption || captionEl.innerHTML || ''\n      const src = itemEl.dataset.pswpSrc || itemEl.href\n      const galleryItem = { el: itemEl, src, w, h, title }\n\n      if (options.useMsrc) {\n        /** If options.useMsrc is true, look for the 'src' attribute of the gallery item thumbnail <img/> element. */\n        const imageEl = itemEl.querySelector('img')\n        if (imageEl) {\n          galleryItem.msrc = imageEl.src\n        }\n      }\n\n      if (options.hoverPreload) {\n        itemEl.addEventListener('mouseover', function itemHover (e) {\n          if (!galleryItem.preloadState) {\n            galleryItem.preloadState = 1\n            preloadImage(\n              src,\n              img => {\n                galleryItem.preloadState = 2\n                galleryItem.w = img.width\n                galleryItem.h = img.height\n                itemEl.removeEventListener('mouseover', itemHover)\n              },\n              () => {\n                /** Reset the preload state in case of error and remove the listener */\n                galleryItem.preloadState = 0\n                itemEl.removeEventListener('mouseover', itemHover)\n              }\n            )\n          }\n        })\n      }\n\n      return galleryItem\n    }\n  )\n\n  const gallery = { el: galleryEl, options, items }\n  galleryEl.addEventListener('click', handleGalleryClick(gallery))\n\n  return gallery\n}\n\nconst build = (elOrSelector, options) => {\n  if (!PhotoSwipe || !PhotoSwipeUI) {\n    console.error(\n      '[PhotoSwippy] PhotoSwipe and PhotoSwipeUI libraries were not found. Was \"PhotoSwippy.init()\" called?'\n    )\n  }\n\n  if (!elOrSelector) return\n\n  const galleryEls =\n    typeof elOrSelector === 'string'\n      ? slice(document.querySelectorAll(elOrSelector))\n      : [elOrSelector]\n\n  galleryEls.forEach(galleryEl => {\n    if (!galleryEl.photoswippy) {\n      galleryCount++\n      const gallery = buildGallery(galleryEl, options)\n      galleryEl.photoswippy = true\n      galleryList[gallery.options.galleryUID] = gallery\n    }\n  })\n\n  /** If url's hash has a 'pid' and a 'gid', let's open that gallery */\n  const urlHash = getURLHash()\n  if (urlHash.pid && urlHash.gid && galleryList[urlHash.gid]) {\n    openPhotoSwipe(galleryList[urlHash.gid], urlHash.pid - 1, null)\n  }\n  refreshTriggers()\n}\n\n/*\n* Search for `data-pswp-trigger=\"gallery-id\"` elements to be used\n* as triggers to open a specific gallery.\n*/\nconst refreshTriggers = () => {\n  const triggers = slice(document.querySelectorAll('[data-pswp-trigger]'))\n  triggers.forEach(trigger => {\n    if (!trigger.photoswippy) {\n      trigger.photoswippy = true\n      trigger.addEventListener('click', function () {\n        const [galleryID, index = 0] = this.dataset.pswpTrigger.split('@')\n        const gallery = galleryList[galleryID]\n        if (!gallery) {\n          console.error(\n            `[PhotoSwippy] Gallery with id '${galleryID}' not found.`\n          )\n        } else {\n          /** Open gallery passing the trigger element and the initial item (always the first gallery entry) */\n          openPhotoSwipe(gallery, parseInt(index), this)\n        }\n      })\n    }\n  })\n}\n\nconst init = (\n  pswpLib = window.PhotoSwipe,\n  pswpUILib = window.PhotoSwipeUI_Default,\n  options\n) => {\n  PhotoSwipe = pswpLib\n  PhotoSwipeUI = pswpUILib\n  PhotoSwipeGlobalOptions = assign(defaultPhotoswippyOptions, options)\n  PhotoswipeTemplate = document.querySelector('.pswp')\n\n  if (!PhotoswipeTemplate) {\n    console.error(\n      '[PhotoSwippy] Photoswipe template (Element with .pswp class) not found.'\n    )\n  }\n\n  // Initialize all available galleries (data-pswp)\n  build('[data-pswp]')\n}\n\nexport default {\n  init,\n  build\n}\n"],"names":["slice","arrayLike","Array","prototype","call","closest","el","fn","parentNode","preloadImage","url","onLoad","onError","tmpImg","Image","onload","onerror","src","selectorMatches","selector","Element","matches","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","assign","Object","target","TypeError","output","index","arguments","length","source","nextKey","hasOwnProperty","PhotoSwipe","PhotoSwipeUI","PhotoSwipeGlobalOptions","PhotoswipeTemplate","galleryCount","galleryList","defaultPhotoswippyOptions","indexSelector","itemSelector","captionSelector","hoverPreload","useMsrc","eventListener","openPhotoSwipe","gallery","curIndex","openTriggerEl","items","querySelector","offsetWidth","offsetHeight","options","getThumbBoundsFn","actionTriggerEl","offsetParent","pageYScroll","window","pageYOffset","document","documentElement","scrollTop","triggerElFrame","getBoundingClientRect","x","left","y","top","w","width","pswpGallery","listen","item","h","preloadState","img","height","updateSize","forEach","listener","name","callback","init","build","elOrSelector","console","error","querySelectorAll","galleryEl","photoswippy","galleryOptions","dataset","pswpOptions","JSON","parse","relevantKeys","keys","filter","k","indexOf","datasetKey","realKey","toLowerCase","substring","galleryUID","pswpId","pswp","map","itemEl","captionEl","pswpSize","split","parseInt","pswpSrc","href","galleryItem","pswpWidth","pswpHeight","title","pswpCaption","innerHTML","imageEl","msrc","addEventListener","itemHover","e","removeEventListener","preventDefault","currentItem","nodeType","actualIndex","node","previousElementSibling","getElementIndex","handleGalleryClick","buildGallery","urlHash","location","hash","reduce","acc","cur","id","pid","gid","refreshTriggers","trigger","galleryID","this","pswpTrigger","pswpLib","pswpUILib","PhotoSwipeUI_Default"],"mappings":"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"}